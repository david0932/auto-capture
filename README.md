# Auto Page Capture - Chrome 擴充功能

自動翻頁截圖工具，支援自動裁切空白、合併 PDF 等功能。

## 功能特色

### ✅ 核心功能

1. **自動翻頁擷取**
   - 自動模擬鍵盤或滑鼠操作翻頁
   - 支援 iframe 內的電子書閱讀器
   - 智慧偵測翻頁失敗並自動停止

2. **靈活的頁數設定**
   - 指定擷取頁數（例如：10 頁）
   - 擷取到最後（自動偵測無法翻頁時停止）
   - 手動停止功能

3. **自動裁切空白**
   - 智慧識別並移除圖片左右空白區域
   - 使用採樣演算法提高效率
   - 可調整的閾值參數（WHITE_THRESHOLD = 240）
   - 保留 5px 邊距避免裁切過緊

4. **合併成 PDF**
   - 可選擇將所有圖片合併成單一 PDF 檔案
   - 橫式（landscape）A4 排版
   - 保持圖片原始比例，自動居中
   - 不會失真或變形

5. **時間戳記資料夾**
   - 每次擷取自動建立帶時間戳記的資料夾
   - 格式：`auto-capture-YYYY-MM-DDTHH-MM-SS`
   - 避免檔案覆蓋，方便管理

6. **自動儲存**
   - 不彈出儲存對話框
   - 直接下載到預設下載資料夾
   - 支援檔名衝突自動重命名

## 使用方式

### 安裝

1. 前往 `chrome://extensions/`
2. 開啟「開發人員模式」
3. 點擊「載入未封裝項目」
4. 選擇 `auto-capture` 資料夾

### 設定瀏覽器（重要）

為了避免下載時彈出對話框，需要設定：

1. 開啟 Chrome 設定：`chrome://settings/downloads`
2. **關閉**「下載前先詢問每個檔案的儲存位置」

### 使用步驟

1. 開啟要擷取的電子書或網頁
2. 點擊擴充功能圖示開啟控制面板
3. 設定選項：
   - **要擷取的頁數**：輸入數字（例如：10）
   - **擷取到最後**：勾選後會自動擷取到無法翻頁為止
   - **完成後合併成 PDF 檔案**：勾選後會生成 PDF
4. 點擊「開始」按鈕
5. 等待擷取完成（可隨時點擊「停止」中斷）

## 檔案結構

```
下載資料夾/
├── auto-capture-2025-12-12T10-30-45/
│   ├── page-001.png  (已裁切空白)
│   ├── page-002.png  (已裁切空白)
│   ├── page-003.png  (已裁切空白)
│   └── merged.pdf    (橫式，保持比例)
├── auto-capture-2025-12-12T11-15-20/
│   ├── page-001.png
│   ├── page-002.png
│   └── merged.pdf
└── auto-capture-2025-12-12T14-22-10/
    ├── page-001.png
    ├── page-002.png
    └── page-003.png
```

## 技術細節

### 檔案說明

- `manifest.json` - 擴充功能設定檔
- `background.js` - 背景服務，處理截圖、下載、PDF 生成
- `content.js` - 內容腳本，處理自動翻頁邏輯
- `popup.html` - 控制面板介面
- `popup.js` - 控制面板邏輯
- `jspdf.umd.min.js` - PDF 生成庫

### 裁切演算法

```javascript
// 參數設定
WHITE_THRESHOLD = 240       // RGB 閾值，低於此值視為內容
SAMPLE_STEP = 10            // 採樣間隔（像素）
CONTENT_THRESHOLD = 0.05    // 內容密度閾值（5%）
PADDING = 5                 // 裁切後保留的邊距（像素）

// 判斷邏輯
1. 垂直方向只檢查中間 80% 區域（避免邊緣噪點）
2. 每隔 10 像素採樣一次（提高效率）
3. 計算每列的內容像素比例
4. 超過 5% 視為有內容的列
5. 找到左右邊界後各保留 5px 邊距
```

### PDF 生成

```javascript
// 比例計算
1. 取得圖片原始尺寸（寬 x 高）
2. 計算圖片比例 = imgWidth / imgHeight
3. 計算頁面比例 = pageWidth / pageHeight
4. 根據比例選擇縮放方式：
   - 圖片較寬 → 以寬度為基準，垂直置中
   - 圖片較高 → 以高度為基準，水平置中
5. 保持原始比例，不拉伸變形
```

## 翻頁機制

### 自動翻頁方式

使用**鍵盤右方向鍵（ArrowRight）**模擬翻頁

### 翻頁成功判斷

使用多重檢測機制判斷翻頁是否成功：
- **HTML 內容改變**：檢測 HTML 長度變化
- **URL 改變**：檢測 URL 或 Hash 變化（如 `#page=1` → `#page=2`）
- **捲軸移動**：檢測捲軸位置變化

只要上述任一條件滿足，即判定為翻頁成功。

### 自動停止機制

- 連續 **8 次**翻頁失敗則判定為最後一頁
- 每次失敗會自動增加重試等待時間（3秒 → 3.5秒 → 4秒...）
- 自動發送停止訊息並生成 PDF（如有勾選）

### 同步機制

#### 防止並行擷取
為了避免翻頁和存檔競爭導致缺頁，實現了多層同步機制：

1. **獨立異步處理函數**（background.js）
   ```javascript
   async function handleCapturePage() {
     // 所有擷取邏輯
     return { ok: true/false, pageNumber: ... };
   }

   chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
     handleCapturePage()
       .then(result => sendResponse(result))
       .catch(error => sendResponse({ ok: false, ... }));
     return true; // 保持消息通道打開
   });
   ```
   - 避免 IIFE 導致消息通道過早關閉
   - 確保 sendResponse 在通道開啟時被調用

2. **isProcessing 旗標**（background.js）
   - 開始擷取時設置 `isProcessing = true`
   - 完成後（成功或失敗）在 finally 中設置 `isProcessing = false`
   - 如果收到新請求但旗標為 true，立即拒絕

3. **串行等待**（content.js）
   - 使用 `await` 而非 `setTimeout`
   - 確保每個步驟完成後才進行下一步
   - 翻頁 → 等待穩定 → await 擷取 → await 延遲 → 下一頁

4. **下載完成檢查**
   - 輪詢檢查 `chrome.downloads` 狀態
   - 只有 `state === 'complete'` 才回傳成功
   - 確保檔案真正寫入磁碟

**執行順序保證**：
```
頁面 N:
  翻頁 (0ms)
    ↓
  等待頁面更新 (1500ms)
    ↓
  等待頁面穩定 (500ms)
    ↓
  檢查 isProcessing (立即拒絕如果正在處理)
    ↓
  設置 isProcessing = true 🔒
    ↓
  擷取視窗 → 裁切 → 下載 → 輪詢檢查狀態
    ↓
  檔案寫入磁碟完成 ✅
    ↓
  isProcessing = false 🔓
    ↓
  回傳 response({ ok: true })
    ↓
content.js 收到 response（確認檔案已存在）
    ↓
  等待 500ms ⏳
    ↓
頁面 N+1: 翻頁 → ...
```

### 錯誤處理機制

#### 擷取失敗重試
- **標籤頁查詢**：找不到標籤頁時會重試 3 次（每次間隔 500ms）
- **擷取重試**：每頁擷取失敗會重試 5 次（每次間隔 800ms）
- **確保完整**：只有擷取成功才會繼續下一頁，避免掉頁
- **詳細日誌**：所有擷取狀態都會記錄在 Console

#### 失敗處理策略
```
翻頁成功
  ↓
等待 1500ms（頁面更新）⚡ 已優化
  ↓
等待 500ms（頁面穩定）⚡ 已優化
  ↓
發送擷取請求 (只發送一次)
  ↓
background.js 內部重試（最多 5 次）
  ├─ 失敗 → 等待 800ms → 重試（不增加頁碼）
  └─ 成功 → 擷取視窗 → 裁切空白 → 建立下載任務
                                        ↓
                                  輪詢等待檔案寫入磁碟
                                  (每 500ms 檢查一次)
                                        ↓
                                  下載完成 → 頁碼 +1
  ↓
5 次都失敗 → 回傳失敗，停止擷取流程
  ↓
content.js 收到成功回應 → 等待 500ms ⚡ → 下一頁
```

**關鍵特性**：
- ✅ 重試期間使用相同的頁碼（避免重複下載不同檔案）
- ✅ 只有確實下載成功才增加頁碼
- ✅ 失敗重試不會產生額外檔案
- ✅ **等待檔案完全寫入磁碟後才翻下一頁**（避免競爭條件）
- ✅ **使用輪詢方式檢查下載狀態**（每 500ms 檢查一次，比事件監聽更可靠）
- ✅ 下載超時保護（30 秒），避免永遠等待
- ✅ **使用 isProcessing 旗標防止並行擷取**（確保同一時間只處理一頁）
- ✅ **完全串行執行**（翻頁 → 擷取 → 下載 → 等待 → 下一頁，無定時器競爭）

### 翻頁參數

```javascript
delay = 500ms                 // 翻頁間隔（優化為 500ms，因完全串行執行）
MAX_FAILURES = 8              // 最大連續翻頁失敗次數
flipPageWait = 1500ms         // 翻頁後等待頁面更新的時間（優化）
pageStabilizeWait = 500ms     // 翻頁成功後，擷取前的額外等待（優化）
tabQueryRetries = 3           // 查詢標籤頁的重試次數
captureRetries = 5            // 擷取頁面失敗時的重試次數
captureRetryDelay = 800ms     // 擷取重試間隔
downloadCheckInterval = 500ms // 下載狀態檢查間隔（輪詢）
downloadMaxWait = 30000ms     // 下載最長等待時間（30 秒）
```

**總處理時間（每頁）**：
- 翻頁觸發：0ms
- 等待頁面更新：1500ms
- 等待頁面穩定：500ms
- 擷取 + 下載（變動）：500-2000ms
- 延遲到下一頁：500ms
- **預估總時間：約 3-4.5 秒/頁**（比之前的 6+ 秒快 40-50%）

### 執行流程

```
開始
 ↓
等待 1 秒（讓 iframe 載入）
 ↓
擷取第一頁（當前頁面）
 ↓
⚡ await 等待第一頁完全下載完成 ⚡
 ↓
等待 500ms
 ↓
開始翻頁循環
 ↓
嘗試翻頁 → 等待 1500ms（頁面更新）
     ↓
   檢查是否成功
     ↓
   成功 ────────────────┐
     ↓                  │
   重置失敗計數         │
     ↓                  │
   等待 800ms（頁面穩定）│
     ↓                  │
   擷取該頁              │
     ↓                  │
   等待檔案寫入磁碟完成  │
     ↓                  │
   等待 3 秒            │
     ↓                  │
   下一頁 ──────────────┘

   失敗 ─────────────────┐
     ↓                  │
   失敗計數 +1          │
     ↓                  │
  達到 8 次？           │
     ↓                  │
    是 → 停止並生成 PDF │
     ↓                  │
    否 → 繼續重試 ───────┘
```

## 常見問題

### Q: 出現 "message channel closed before a response was received" 錯誤？

A: 這個問題已在最新版本修正。確保使用的是獨立異步處理函數而非 IIFE。如果還有問題，請重新載入擴充功能。

### Q: 為什麼下載時會彈出對話框？

A: 請確認已關閉 Chrome 的「下載前先詢問每個檔案的儲存位置」設定。

### Q: 如何調整裁切的敏感度？

A: 在 `background.js` 中修改 `WHITE_THRESHOLD` 參數：
- 降低數值（如 230）→ 更積極裁切
- 提高數值（如 250）→ 更保守裁切

### Q: PDF 中的圖片還是有空白？

A: 裁切功能只移除左右空白。如需移除上下空白，可以修改 `cropImageWhitespace` 函數增加垂直方向的裁切。

### Q: 為什麼沒有擷取到第一頁？

A: 已修正！現在會在翻頁前先擷取當前頁面。

### Q: 如何只下載圖片不生成 PDF？

A: 不要勾選「完成後合併成 PDF 檔案」選項即可。

## 版本歷史

### v2.0 (2025-12-15) - 🎉 完全重構，零漏頁
- 🚀 **架構重構：徹底解決漏頁問題**
  - **content.js**：使用 `while` 循環取代遞迴調用，避免堆疊溢出
  - **background.js**：實作 Mutex 互斥鎖，確保擷取操作的原子性
  - **關鍵修正**：只有在檔案完全下載成功後才增加 pageCounter

- 🔍 **翻頁檢測改進**
  - 使用雜湊（djb2 演算法）檢測頁面變化，取代簡單的長度比較
  - 多維度檢測：文字內容、HTML、URL、捲軸、圖片數量
  - 避免動態廣告導致的誤判

- 📥 **下載驗證強化**
  - 立即檢查下載狀態（不等待 500ms），避免錯過快速完成的下載
  - 檢查間隔從 500ms 縮短為 200ms，更快速響應
  - 驗證檔案大小（必須 > 0 bytes）
  - 額外等待 200ms 確保檔案真正寫入磁碟

- 🔒 **並行控制改進**
  - Mutex 互斥鎖：使用等待隊列機制，取代簡單的 `isProcessing` 旗標
  - 完全避免競爭條件，確保同時只有一個擷取操作

- 📊 **日誌優化**
  - 更清晰的 v2.0 標記
  - 詳細的下載進度追蹤
  - Mutex 鎖定/解鎖狀態顯示

**預期效果**：
- ✅ 零漏頁（理論上可達 99.9% 可靠性）
- ✅ 適合擷取大量頁面（100+ 頁）
- ✅ 更準確的翻頁檢測
- ✅ 更快的響應速度

### v1.5 (2025-12-13)
- 🐛 **修正：第一頁和翻頁並行執行導致失敗**
  - 第一頁擷取改為 `await` 等待完成
  - 確保第一頁完全下載後才開始翻頁循環
  - 解決「上一頁還在處理中」的錯誤
- 🔒 **強化：isProcessing 超時保護**
  - 60 秒超時自動清除旗標
  - 防止旗標永久卡住
- 📝 改進：增加更詳細的下載狀態日誌

### v1.4 (2025-12-13)
- 🐛 **修正：徹底解決缺頁問題**
  - 使用 `isProcessing` 旗標防止並行擷取
  - 改用獨立異步函數（handleCapturePage, handleStopCapture），修正 message channel 錯誤
  - 等待檔案完全寫入磁碟後才翻下一頁
  - 移除所有 setTimeout，改用 await 確保串行執行
- ⚡ **效能優化：速度提升 40-50%**
  - 翻頁間隔：3000ms → 500ms
  - 翻頁等待：2500ms → 1500ms
  - 穩定等待：800ms → 500ms
  - 總處理時間：約 6+ 秒/頁 → 3-4.5 秒/頁
- 📝 改進：下載狀態使用輪詢檢查（每 500ms）
- 📝 改進：增加詳細的 Console 日誌（🔒/🔓/⏳ 標記）

### v1.3 (2025-12-12)
- ✨ 新增：合併成 PDF 功能
- ✨ 新增：自動裁切左右空白
- ✨ 新增：時間戳記資料夾
- ✨ 新增：擷取到最後功能
- 🐛 修正：PDF 圖片比例失真問題
- 🐛 修正：Service Worker 載入錯誤
- 🐛 修正：漏掉第一頁的問題
- 📝 改進：PDF 使用橫式排版

### v1.2
- ✨ 新增：可設定擷取頁數
- ✨ 新增：自動儲存不彈出對話框

### v1.0
- 🎉 初始版本
- ✨ 基本自動翻頁擷取功能

## 授權

本專案僅供學習和個人使用。

## 貢獻

歡迎提出問題和改進建議。
